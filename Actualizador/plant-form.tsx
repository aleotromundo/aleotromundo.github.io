// src/components/plant-form.tsx"use client";import type { Plant } from "@/lib/plant-types";import { generatePlantDescription } from "@/ai/flows/generate-plant-description";import { generatePlantName } from "@/ai/flows/generate-plant-name";import { generatePdfBackground } from "@/ai/flows/generate-pdf-background"; // For AI backgroundimport { Button } from "@/components/ui/button";import { Input } from "@/components/ui/input";import { Label } from "@/components/ui/label";import { Textarea } from "@/components/ui/textarea";import { useToast } from "@/hooks/use-toast";import { Camera, Loader2, Sparkles, Wand2, Video, RotateCcw, Image as ImageIcon } from "lucide-react";import Image from "next/image";import React, { useState, ChangeEvent, useRef, useEffect } from "react";import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";interface PlantFormProps {  onSavePlant: (plant: Omit<Plant, "id" | "aiBackgroundDataUri"> & { aiBackgroundDataUri?: string }) => Promise<void>;  onClose: () => void;}export function PlantForm({ onSavePlant, onClose }: PlantFormProps) {  const [name, setName] = useState("");  const [description, setDescription] = useState("");  const [photoFile, setPhotoFile] = useState<File | null>(null);  const [photoPreview, setPhotoPreview] = useState<string | null>(null);    const [isGeneratingName, setIsGeneratingName] = useState(false);  const [isGeneratingDescription, setIsGeneratingDescription] = useState(false);  const [isSaving, setIsSaving] = useState(false);  const [isCameraMode, setIsCameraMode] = useState(false);  const [hasCameraPermission, setHasCameraPermission] = useState<boolean | null>(null);  const videoRef = useRef<HTMLVideoElement>(null);  const canvasRef = useRef<HTMLCanvasElement>(null);  const { toast } = useToast();  useEffect(() => {    let stream: MediaStream | null = null;    const getCameraPermission = async () => {      if (!isCameraMode) {        if (videoRef.current && videoRef.current.srcObject) {          (videoRef.current.srcObject as MediaStream).getTracks().forEach(track => track.stop());          videoRef.current.srcObject = null;        }        return;      }      try {        stream = await navigator.mediaDevices.getUserMedia({ video: true });        setHasCameraPermission(true);        if (videoRef.current) {          videoRef.current.srcObject = stream;        }      } catch (error) {        console.error('Error al acceder a la cámara:', error);        setHasCameraPermission(false);        toast({          variant: 'destructive',          title: 'Acceso a Cámara Denegado',          description: 'Por favor, habilita los permisos de cámara en la configuración de tu navegador.',        });        setIsCameraMode(false); // Switch back if no permission      }    };    getCameraPermission();    return () => {      if (stream) {        stream.getTracks().forEach(track => track.stop());      }      if (videoRef.current && videoRef.current.srcObject) {        (videoRef.current.srcObject as MediaStream).getTracks().forEach(track => track.stop());         videoRef.current.srcObject = null;      }    };  }, [isCameraMode, toast]);  const handlePhotoChange = (event: ChangeEvent<HTMLInputElement>) => {    const file = event.target.files?.[0];    if (file) {      setPhotoFile(file);      const reader = new FileReader();      reader.onloadend = () => {        setPhotoPreview(reader.result as string);      };      reader.readAsDataURL(file);      setIsCameraMode(false); // Switch off camera mode if file is uploaded    }  };  const handleGenerateName = async () => {    if (!photoPreview) {      toast({ title: "Foto Necesaria", description: "Por favor, selecciona o toma una foto primero para generar un nombre.", variant: "destructive" });      return;    }    setIsGeneratingName(true);    try {      const result = await generatePlantName({ photoDataUri: photoPreview });      setName(result.plantName);      toast({ title: "¡Nombre Generado!", description: "Se ha sugerido un nombre para tu planta." });    } catch (error) {      console.error("Error generando nombre de planta:", error);      toast({ title: "Error", description: "No se pudo generar el nombre de la planta.", variant: "destructive" });    } finally {      setIsGeneratingName(false);    }  };  const handleGenerateDescription = async () => {    if (!photoPreview) {      toast({ title: "Foto Necesaria", description: "Por favor, selecciona o toma una foto primero para generar una descripción.", variant: "destructive" });      return;    }    if (!name) {      toast({ title: "Nombre Necesario", description: "Por favor, proporciona un nombre o genera uno primero.", variant: "destructive" });      return;    }    setIsGeneratingDescription(true);    try {      const result = await generatePlantDescription({ photoDataUri: photoPreview, plantName: name });      setDescription(result.plantDescription);      toast({ title: "¡Descripción Generada!", description: "Se ha sugerido una descripción para tu planta." });    } catch (error) {      console.error("Error generando descripción de planta:", error);      toast({ title: "Error", description: "No se pudo generar la descripción de la planta.", variant: "destructive" });    } finally {      setIsGeneratingDescription(false);    }  };  const handleSubmit = async (event: React.FormEvent) => {    event.preventDefault();    if (!photoPreview || !name) {      toast({ title: "Información Faltante", description: "Por favor, proporciona una foto y un nombre para la planta.", variant: "destructive" });      return;    }    setIsSaving(true);    try {      let aiBackgroundDataUri: string | undefined = undefined;      try {        const backgroundResult = await generatePdfBackground({ plantName: name, plantDescription: description });        aiBackgroundDataUri = backgroundResult.backgroundDataUri;        toast({ title: "Fondo IA Generado", description: "Fondo creativo listo para la página PDF de tu planta." });      } catch (bgError) {        console.error("Error generando fondo para PDF:", bgError);        toast({ title: "Error de Fondo", description: "No se pudo generar el fondo con IA, se usará el predeterminado.", variant: "destructive" });      }      await onSavePlant({ name, description, photoDataUri: photoPreview, aiBackgroundDataUri });      setName("");      setDescription("");      setPhotoFile(null);      setPhotoPreview(null);      setIsCameraMode(false);      onClose();     } catch (error) {      console.error("Error guardando planta:", error);      toast({ title: "Error al Guardar", description: "No se pudo guardar la planta.", variant: "destructive" });    } finally {      setIsSaving(false);    }  };    const handleTakePhoto = () => {    if (videoRef.current && canvasRef.current) {      const video = videoRef.current;      const canvas = canvasRef.current;      canvas.width = video.videoWidth;      canvas.height = video.videoHeight;      const context = canvas.getContext('2d');      if (context) {        context.drawImage(video, 0, 0, canvas.width, canvas.height);        const dataUri = canvas.toDataURL('image/png');        setPhotoPreview(dataUri);        setPhotoFile(null); // Clear file if photo is taken        setIsCameraMode(false); // Exit camera mode after taking photo      }    }  };  const clearPhoto = () => {    setPhotoFile(null);    setPhotoPreview(null);    if (canvasRef.current) {      const context = canvasRef.current.getContext('2d');      if (context) {        context.clearRect(0,0, canvasRef.current.width, canvasRef.current.height);      }    }  }  return (    <form onSubmit={handleSubmit} className="space-y-6 p-2">      <div>        <Label htmlFor="photo" className="mb-2 block text-sm font-medium">Foto de la Planta</Label>                {isCameraMode ? (          <div className="space-y-2">            <video ref={videoRef} className="w-full aspect-video rounded-md bg-muted" autoPlay muted playsInline />            <canvas ref={canvasRef} className="hidden" />            {hasCameraPermission === false && (              <Alert variant="destructive">                <AlertTitle>Acceso a Cámara Denegado</AlertTitle>                <AlertDescription>                  Por favor, habilita los permisos de cámara en la configuración de tu navegador y refresca la página.                </AlertDescription>              </Alert>            )}             {hasCameraPermission === true && (                 <Button type="button" onClick={handleTakePhoto} className="w-full" variant="outline">                    <Camera className="mr-2" /> Tomar Foto                 </Button>             )}            <Button type="button" onClick={() => setIsCameraMode(false)} className="w-full" variant="ghost">              <ImageIcon className="mr-2" /> Subir Archivo            </Button>          </div>        ) : (          <div className="mt-1 flex flex-col items-center justify-center px-6 pt-5 pb-6 border-2 border-dashed rounded-md space-y-2">            {photoPreview ? (              <div className="relative w-full h-48">                <Image src={photoPreview} alt="Vista previa de la planta" layout="fill" objectFit="contain" data-ai-hint="plant user-photo" />              </div>            ) : (              <div className="space-y-1 text-center">                <Camera className="mx-auto h-12 w-12 text-muted-foreground" />                <div className="flex text-sm text-muted-foreground">                  <Label                    htmlFor="photo-upload"                    className="relative cursor-pointer rounded-md font-medium text-primary hover:text-primary/80 focus-within:outline-none focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-ring"                  >                    <span>Subir un archivo</span>                    <Input id="photo-upload" name="photo-upload" type="file" accept="image/*" className="sr-only" onChange={handlePhotoChange} />                  </Label>                  <p className="pl-1">o arrastrar y soltar</p>                </div>                <p className="text-xs text-muted-foreground">PNG, JPG, GIF hasta 10MB</p>              </div>            )}            <div className="flex gap-2 mt-2">                <Button type="button" variant="outline" size="sm" onClick={() => setIsCameraMode(true)}>                    <Video className="mr-2"/> Usar Cámara                </Button>                {photoPreview && (                <Button type="button" variant="outline" size="sm" onClick={clearPhoto}>                    <RotateCcw className="mr-2"/> Cambiar Foto                </Button>                )}            </div>          </div>        )}      </div>      <div>        <Label htmlFor="name" className="mb-1 block text-sm font-medium">Nombre de la Planta</Label>        <div className="flex gap-2">          <Input id="name" value={name} onChange={(e) => setName(e.target.value)} required placeholder="Ej: Monstera Deliciosa" />          <Button type="button" variant="outline" onClick={handleGenerateName} disabled={isGeneratingName || !photoPreview} aria-label="Generar Nombre con IA">            {isGeneratingName ? <Loader2 className="animate-spin" /> : <Sparkles className="mr-1 h-4 w-4" />} IA          </Button>        </div>      </div>      <div>        <Label htmlFor="description" className="mb-1 block text-sm font-medium">Descripción</Label>        <div className="flex flex-col gap-2">          <Textarea            id="description"            value={description}            onChange={(e) => setDescription(e.target.value)}            rows={4}            placeholder="Ej: Hojas grandes, verdes y brillantes con divisiones características..."          />          <Button type="button" variant="outline" onClick={handleGenerateDescription} disabled={isGeneratingDescription || !photoPreview || !name} className="self-start" aria-label="Generar Descripción con IA">            {isGeneratingDescription ? <Loader2 className="animate-spin" /> : <Wand2 className="mr-1 h-4 w-4" />} IA Llenar Descripción          </Button>        </div>      </div>      <div className="flex justify-end gap-3 pt-2">        <Button type="button" variant="outline" onClick={() => { onClose(); setIsCameraMode(false);}} disabled={isSaving}>          Cancelar        </Button>        <Button type="submit" disabled={isSaving || !photoPreview || !name} variant="default">          {isSaving ? <Loader2 className="animate-spin mr-2" /> : null}          Guardar Planta        </Button>      </div>    </form>  );}